---
name: Формы
permalink: '/guide/forms'
---

# Формы


Формы в Preact работают так же, как в React, за исключением того, что отсутствует поддержка "static" для начальных значений свойств/атрибутов.


**[Документация по формам React](https://facebook.github.io/react/docs/forms.html)**


## Управляемые и неуправляемые компоненты

Документация React по ["управляемым" компонентам](https://facebook.github.io/react/docs/forms.html#controlled-components) и ["неуправляемым" компонентам](https://facebook.github.io/react/docs/forms.html#uncontrolled-components) чрезвычайно полезно для понимания как работать с HTML-формами, имеющими двунаправленный поток данных и как создать их из контекста компонентно-ориентированного рендеринга видтуального DOM, который обычно имеет однонаправленный поток данных.

Как правило, вы должны пытаться использовать _Controlled_ (управляемые) компоненты. Однако, при создании автономных компонентов или врапперов для сторонних UI-библиотек, всё же может быть полезно использовать ваш компонент в качестве точки монтирования для не-preact функциональности. Для таких задач хорошо подходят "неконтролируемые" компоненты.


## Флажки и переключатели

Флажки и переключатели (`<input type="checkbox|radio">`) могут сперва вызвать путаницу при создании контролируемых форм. Это связано с тем, что в неконтролируемой среде мы обычно позволяем браузеру "переключать" или "отмечать" флажок или переключатель, слушать событие изменения и реагировать на новое значение. Однако, этот метод не очень хорошо подходит в случаях, когда пользовательский интерфейс всегда обновляется автоматически в ответ на изменения состояния и атрибутов.


> **Пример:** Допустим, мы слушаем событие "change" для флажка, которое вызывается, когда флажок отмечен или не отмечен пользователем. В нашем обработчике этого события мы устанавливаем полученное новое значение значение флажка в `state` (состояние).  Это приведет к повторному рендерингу нашего компонента, который переустанавливает значение флажка в значение из состояния.  Это необязательно, отому что мы просто взяли значение из DOM, но затем перерендерили его с желаемым значением.


Таким образом, вместо прослушивания события `change`, мы должны слушать событие `click`, которое вызывается каждый раз, когда пользователь кликает на флажок _или ассоциированный с ним `<label>`_.  Флажки просто переключаются между логическими значениями `true` и `false`, так что клик на флажок или метку просто инвертирует любое значение в состоянии, вызовет перерендер, установив значение флажка в то, которое нам нужно.

### Пример флажка

```js
class MyForm extends Component {
    toggle = e => {
        let checked = !this.state.checked;
        this.setState({ checked });
    };
    render({ }, { checked }) {
        return (
            <label>
                <input
                    type="checkbox"
                    checked={checked}
                    onClick={this.toggle} />
            </label>
        );
    }
}
```
